<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reglibcpp: reg::expression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">reglibcpp
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">(Naïve) C++ implementation of models for regular languages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>reg</b></li><li class="navelem"><a class="el" href="classreg_1_1expression.html">expression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classreg_1_1expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reg::expression Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents <a href="https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory">formal regular expressions</a>.  
 <a href="classreg_1_1expression.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="expression_8h_source.html">expression.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Token literals as used in <em>Introduction to Automata Theory, Languages, and Computation</em> by Hopcroft, Motwani and Ullman.  <a href="structreg_1_1expression_1_1literals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html">parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses regular expressions.  <a href="structreg_1_1expression_1_1parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7fab42d347ccf6c012c9176166723329"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a7fab42d347ccf6c012c9176166723329">operation</a> { <br />
&#160;&#160;<b>empty</b>, 
<b>symbol</b>, 
<b>kleene</b>, 
<b>concatenation</b>, 
<br />
&#160;&#160;<b>alternation</b>
<br />
 }<tr class="memdesc:a7fab42d347ccf6c012c9176166723329"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different purposes an RE may fulfill.  <a href="classreg_1_1expression.html#a7fab42d347ccf6c012c9176166723329">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7fab42d347ccf6c012c9176166723329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b770265b81b3c88566a66ffbc8034c"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classreg_1_1expression.html">expression</a> const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a></td></tr>
<tr class="memdesc:a74b770265b81b3c88566a66ffbc8034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type used to handle regular expressions.  <a href="#a74b770265b81b3c88566a66ffbc8034c">More...</a><br /></td></tr>
<tr class="separator:a74b770265b81b3c88566a66ffbc8034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c0bd3dc0fafcc73b8e9ab8efb8b6daa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa">size</a> () const</td></tr>
<tr class="memdesc:a5c0bd3dc0fafcc73b8e9ab8efb8b6daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the size of this RE's tree representation.  <a href="#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa">More...</a><br /></td></tr>
<tr class="separator:a5c0bd3dc0fafcc73b8e9ab8efb8b6daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9542c8ff993613f1069590ab96fc37f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreg_1_1expression.html#a7fab42d347ccf6c012c9176166723329">operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#ab9542c8ff993613f1069590ab96fc37f">getOperation</a> () const</td></tr>
<tr class="memdesc:ab9542c8ff993613f1069590ab96fc37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports this RE's function.  <a href="#ab9542c8ff993613f1069590ab96fc37f">More...</a><br /></td></tr>
<tr class="separator:ab9542c8ff993613f1069590ab96fc37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7efc0ec02bf455600c061b3feb6dc8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#aa7efc0ec02bf455600c061b3feb6dc8f">operator==</a> (<a class="el" href="classreg_1_1expression.html">expression</a> const &amp;r) const</td></tr>
<tr class="memdesc:aa7efc0ec02bf455600c061b3feb6dc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this RE is semantically equivalent to another one.  <a href="#aa7efc0ec02bf455600c061b3feb6dc8f">More...</a><br /></td></tr>
<tr class="separator:aa7efc0ec02bf455600c061b3feb6dc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e07c56d3c440e55cf777acc9757fb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#ac7e07c56d3c440e55cf777acc9757fb8">operator!=</a> (<a class="el" href="classreg_1_1expression.html">expression</a> const &amp;r) const</td></tr>
<tr class="memdesc:ac7e07c56d3c440e55cf777acc9757fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this RE is semantically different from another one.  <a href="#ac7e07c56d3c440e55cf777acc9757fb8">More...</a><br /></td></tr>
<tr class="separator:ac7e07c56d3c440e55cf777acc9757fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e6c61b7f458c7b5397aa7d2c37c5e9"><td class="memItemLeft" align="right" valign="top">char32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a17e6c61b7f458c7b5397aa7d2c37c5e9">extractSymbol</a> () const</td></tr>
<tr class="memdesc:a17e6c61b7f458c7b5397aa7d2c37c5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports this <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol expression</a>'s UTF-32-encoded symbol.  <a href="#a17e6c61b7f458c7b5397aa7d2c37c5e9">More...</a><br /></td></tr>
<tr class="separator:a17e6c61b7f458c7b5397aa7d2c37c5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee9200c20a411b34b28136139d9247a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a3ee9200c20a411b34b28136139d9247a">extractUtf8Symbol</a> () const</td></tr>
<tr class="memdesc:a3ee9200c20a411b34b28136139d9247a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports this <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol expression</a>'s UTF-8-encoded symbol.  <a href="#a3ee9200c20a411b34b28136139d9247a">More...</a><br /></td></tr>
<tr class="separator:a3ee9200c20a411b34b28136139d9247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac50d9ca88f12425e26b23768fc376b"><td class="memItemLeft" align="right" valign="top">std::u32string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a> () const</td></tr>
<tr class="memdesc:a3ac50d9ca88f12425e26b23768fc376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes this RE in UTF-32-encoded human-readable form.  <a href="#a3ac50d9ca88f12425e26b23768fc376b">More...</a><br /></td></tr>
<tr class="separator:a3ac50d9ca88f12425e26b23768fc376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f4fc0ee2c5dc0ea5af32547844275f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a47f4fc0ee2c5dc0ea5af32547844275f">to_string</a> () const</td></tr>
<tr class="memdesc:a47f4fc0ee2c5dc0ea5af32547844275f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes this RE in UTF-32-encoded human-readable form.  <a href="#a47f4fc0ee2c5dc0ea5af32547844275f">More...</a><br /></td></tr>
<tr class="separator:a47f4fc0ee2c5dc0ea5af32547844275f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a145472f58604d06129f99caca5f1b8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a9a145472f58604d06129f99caca5f1b8">begin</a> () const</td></tr>
<tr class="memdesc:a9a145472f58604d06129f99caca5f1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code>iterator</code> pointing to this RE's first subexpression.  <a href="#a9a145472f58604d06129f99caca5f1b8">More...</a><br /></td></tr>
<tr class="separator:a9a145472f58604d06129f99caca5f1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1063c38d3604aafcd25873ab901e86c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a1063c38d3604aafcd25873ab901e86c7">end</a> () const</td></tr>
<tr class="memdesc:a1063c38d3604aafcd25873ab901e86c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <code>iterator</code> pointing behind this RE's last subexpression.  <a href="#a1063c38d3604aafcd25873ab901e86c7">More...</a><br /></td></tr>
<tr class="separator:a1063c38d3604aafcd25873ab901e86c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a076ba2638a585eaf61bd0a2b54c263ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">spawnEmptySet</a> ()</td></tr>
<tr class="memdesc:a076ba2638a585eaf61bd0a2b54c263ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE representing the empty set &empty;.  <a href="#a076ba2638a585eaf61bd0a2b54c263ab">More...</a><br /></td></tr>
<tr class="separator:a076ba2638a585eaf61bd0a2b54c263ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af248c8a4fac30924f5163f1bcbc378a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">spawnEmptyString</a> ()</td></tr>
<tr class="memdesc:af248c8a4fac30924f5163f1bcbc378a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE representing the empty string &epsilon;.  <a href="#af248c8a4fac30924f5163f1bcbc378a9">More...</a><br /></td></tr>
<tr class="separator:af248c8a4fac30924f5163f1bcbc378a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928ef6b48e0f9edb7b10a94d115b9ef1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">spawnSymbol</a> (char32_t symbol)</td></tr>
<tr class="memdesc:a928ef6b48e0f9edb7b10a94d115b9ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE representing the given UTF-32-encoded symbol.  <a href="#a928ef6b48e0f9edb7b10a94d115b9ef1">More...</a><br /></td></tr>
<tr class="separator:a928ef6b48e0f9edb7b10a94d115b9ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f8314b5a4b6cd4494bba6b74215549"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#aa7f8314b5a4b6cd4494bba6b74215549">spawnSymbol</a> (std::string utf8Symbol)</td></tr>
<tr class="memdesc:aa7f8314b5a4b6cd4494bba6b74215549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for a UTF-8-encoded symbol.  <a href="#aa7f8314b5a4b6cd4494bba6b74215549">More...</a><br /></td></tr>
<tr class="separator:aa7f8314b5a4b6cd4494bba6b74215549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0652a05601359b82254a8db1b0c9bd4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#ad0652a05601359b82254a8db1b0c9bd4">spawnKleene</a> (<a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const &amp;b, bool optimized=true, bool aggressive=false)</td></tr>
<tr class="memdesc:ad0652a05601359b82254a8db1b0c9bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE representing the Kleene closure of a given RE.  <a href="#ad0652a05601359b82254a8db1b0c9bd4">More...</a><br /></td></tr>
<tr class="separator:ad0652a05601359b82254a8db1b0c9bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6004691c6a9bdc5edb45640ed8b0c83e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a6004691c6a9bdc5edb45640ed8b0c83e">spawnConcatenation</a> (<a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const &amp;l, <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const &amp;r, bool optimized=true, bool aggressive=false)</td></tr>
<tr class="memdesc:a6004691c6a9bdc5edb45640ed8b0c83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE representing the concatenation of two given REs.  <a href="#a6004691c6a9bdc5edb45640ed8b0c83e">More...</a><br /></td></tr>
<tr class="separator:a6004691c6a9bdc5edb45640ed8b0c83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6474996cf285d3bc20dc9fd41eebd9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a7d6474996cf285d3bc20dc9fd41eebd9">spawnAlternation</a> (<a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const &amp;l, <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> const &amp;r, bool optimized=true, bool aggressive=false)</td></tr>
<tr class="memdesc:a7d6474996cf285d3bc20dc9fd41eebd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE representing the alternation of two given REs.  <a href="#a7d6474996cf285d3bc20dc9fd41eebd9">More...</a><br /></td></tr>
<tr class="separator:a7d6474996cf285d3bc20dc9fd41eebd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c50a9f610b501317c5708ca252e590"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#ae9c50a9f610b501317c5708ca252e590">spawnFromString</a> (std::u32string const &amp;re, <a class="el" href="structreg_1_1expression_1_1literals.html">literals</a> lits=<a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>(), bool optimized=false, bool aggressive=false)</td></tr>
<tr class="memdesc:ae9c50a9f610b501317c5708ca252e590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives an RE encoded in a given string.  <a href="#ae9c50a9f610b501317c5708ca252e590">More...</a><br /></td></tr>
<tr class="separator:ae9c50a9f610b501317c5708ca252e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781d283fd52850c39b6a8f8542fcc7c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a781d283fd52850c39b6a8f8542fcc7c1">spawnFromString</a> (std::string const &amp;utf8Re, <a class="el" href="structreg_1_1expression_1_1literals.html">literals</a> lits=<a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>(), bool optimized=false, bool aggressive=false)</td></tr>
<tr class="memdesc:a781d283fd52850c39b6a8f8542fcc7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above for a UTF-8-encoded string.  <a href="#a781d283fd52850c39b6a8f8542fcc7c1">More...</a><br /></td></tr>
<tr class="separator:a781d283fd52850c39b6a8f8542fcc7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7ca9935b7acaa0ea9180d8755b22798e"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; std::wstring_convert&lt; std::codecvt_utf8&lt; char32_t &gt;, char32_t &gt; &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">converter</a></td></tr>
<tr class="memdesc:a7ca9935b7acaa0ea9180d8755b22798e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts between UTF-8-encoded and UTF-32-encoded strings.  <a href="#a7ca9935b7acaa0ea9180d8755b22798e">More...</a><br /></td></tr>
<tr class="separator:a7ca9935b7acaa0ea9180d8755b22798e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents <a href="https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory">formal regular expressions</a>. </p>
<p>One should never need to handle such an object directly, however, much less copy or move it and therefore copy and move constructors are deleted.</p>
<p>To work with regular expressions, one should use <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a>, which aliases a <code>shared_ptr</code> to an actual object and can be copied and moved to one's heart's content. To access member functions, one might dereference <code>exptr</code>s temporarily or, better yet, use the arrow <code>-&gt;</code> operator.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c" title="This is the type used to handle regular expressions. ">expression::exptr</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8h_source.html#l00031">31</a> of file <a class="el" href="expression_8h_source.html">expression.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a74b770265b81b3c88566a66ffbc8034c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b770265b81b3c88566a66ffbc8034c">&#9670;&nbsp;</a></span>exptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classreg_1_1expression.html">expression</a> const&gt; <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type used to handle regular expressions. </p>
<p>Every method works on <code>shared_ptr</code>s to the actual regular expressions, to help with basic comparisons and to save memory.</p>
<p>For example, every <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol</a>'s (and the <a class="el" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">empty string</a>'s and the <a class="el" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">empty set</a>'s) regular expression is only instantiated once and then pointed to by as many <code>exptr</code>s as one likes. </p>

<p class="definition">Definition at line <a class="el" href="expression_8h_source.html#l00043">43</a> of file <a class="el" href="expression_8h_source.html">expression.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7fab42d347ccf6c012c9176166723329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fab42d347ccf6c012c9176166723329">&#9670;&nbsp;</a></span>operation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classreg_1_1expression.html#a7fab42d347ccf6c012c9176166723329">reg::expression::operation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different purposes an RE may fulfill. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab" title="Gives an RE representing the empty set ∅. ">spawnEmptySet</a> </dd>
<dd>
<a class="el" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9" title="Gives an RE representing the empty string ε. ">spawnEmptyString</a> </dd>
<dd>
<a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1" title="Gives an RE representing the given UTF-32-encoded symbol. ">spawnSymbol</a> </dd>
<dd>
<a class="el" href="classreg_1_1expression.html#ad0652a05601359b82254a8db1b0c9bd4" title="Gives an RE representing the Kleene closure of a given RE. ">spawnKleene</a> </dd>
<dd>
<a class="el" href="classreg_1_1expression.html#a6004691c6a9bdc5edb45640ed8b0c83e" title="Gives an RE representing the concatenation of two given REs. ">spawnConcatenation</a> </dd>
<dd>
<a class="el" href="classreg_1_1expression.html#a7d6474996cf285d3bc20dc9fd41eebd9" title="Gives an RE representing the alternation of two given REs. ">spawnAlternation</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8h_source.html#l00083">83</a> of file <a class="el" href="expression_8h_source.html">expression.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;{ empty, symbol, kleene, concatenation, alternation };</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a145472f58604d06129f99caca5f1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a145472f58604d06129f99caca5f1b8">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> &gt;::const_iterator reg::expression::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <code>iterator</code> pointing to this RE's first subexpression. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00288">288</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;                                                              {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  <span class="keywordflow">return</span> subExpressions.cbegin();</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a1063c38d3604aafcd25873ab901e86c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1063c38d3604aafcd25873ab901e86c7">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> &gt;::const_iterator reg::expression::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <code>iterator</code> pointing behind this RE's last subexpression. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00293">293</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                                                            {</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;  <span class="keywordflow">return</span> subExpressions.cend();</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a17e6c61b7f458c7b5397aa7d2c37c5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e6c61b7f458c7b5397aa7d2c37c5e9">&#9670;&nbsp;</a></span>extractSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char32_t reg::expression::extractSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports this <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol expression</a>'s UTF-32-encoded symbol. </p>
<p><b>This method should only be called on an object whose <a class="el" href="classreg_1_1expression.html#ab9542c8ff993613f1069590ab96fc37f">function</a> is confirmed to be that of a <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol</a>!</b> </p><dl class="section return"><dt>Returns</dt><dd>the <code>char</code> encoded within this <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol expression</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00216">216</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                                         {</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keyword">auto</span> it = std::find_if(</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      expression::symbols.<a class="code" href="classreg_1_1expression.html#a9a145472f58604d06129f99caca5f1b8">begin</a>(),</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      expression::symbols.<a class="code" href="classreg_1_1expression.html#a1063c38d3604aafcd25873ab901e86c7">end</a>(),</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      [&amp;](pair&lt;char32_t,exptr&gt; <span class="keyword">const</span>&amp; entry)-&gt;<span class="keywordtype">bool</span>{<span class="keywordflow">return</span> entry.second.get() == <span class="keyword">this</span>;}</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  );</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="preprocessor">  #ifdef __EXCEPTIONS</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  <span class="keywordflow">if</span> (it == expression::symbols.<a class="code" href="classreg_1_1expression.html#a1063c38d3604aafcd25873ab901e86c7">end</a>()) {</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">throw</span> std::logic_error(<span class="stringliteral">&quot;This RE does not seem to be a valid symbol expression.&quot;</span>);</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  }</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <span class="keywordflow">return</span> it-&gt;first;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a9a145472f58604d06129f99caca5f1b8"><div class="ttname"><a href="classreg_1_1expression.html#a9a145472f58604d06129f99caca5f1b8">reg::expression::begin</a></div><div class="ttdeci">std::vector&lt; exptr &gt;::const_iterator begin() const</div><div class="ttdoc">Returns an iterator pointing to this RE's first subexpression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00288">expression.cpp:288</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a1063c38d3604aafcd25873ab901e86c7"><div class="ttname"><a href="classreg_1_1expression.html#a1063c38d3604aafcd25873ab901e86c7">reg::expression::end</a></div><div class="ttdeci">std::vector&lt; exptr &gt;::const_iterator end() const</div><div class="ttdoc">Returns an iterator pointing behind this RE's last subexpression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00293">expression.cpp:293</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ee9200c20a411b34b28136139d9247a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee9200c20a411b34b28136139d9247a">&#9670;&nbsp;</a></span>extractUtf8Symbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string reg::expression::extractUtf8Symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports this <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol expression</a>'s UTF-8-encoded symbol. </p>
<p><b>This method should only be called on an object whose <a class="el" href="classreg_1_1expression.html#ab9542c8ff993613f1069590ab96fc37f">function</a> is confirmed to be that of a <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol</a>!</b> </p><dl class="section return"><dt>Returns</dt><dd>the <code>char</code> encoded within this <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol expression</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00235">235</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;                                           {</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  char32_t symbol(<a class="code" href="classreg_1_1expression.html#a17e6c61b7f458c7b5397aa7d2c37c5e9">extractSymbol</a>());</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="keywordflow">if</span> (symbol == U<span class="charliteral">&#39;\0&#39;</span>) {</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordflow">return</span> string();</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">converter</a>-&gt;to_bytes(<a class="code" href="classreg_1_1expression.html#a17e6c61b7f458c7b5397aa7d2c37c5e9">extractSymbol</a>());</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  }</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a7ca9935b7acaa0ea9180d8755b22798e"><div class="ttname"><a href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">reg::expression::converter</a></div><div class="ttdeci">static std::unique_ptr&lt; std::wstring_convert&lt; std::codecvt_utf8&lt; char32_t &gt;, char32_t &gt; &gt; const converter</div><div class="ttdoc">Converts between UTF-8-encoded and UTF-32-encoded strings. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00096">expression.h:96</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a17e6c61b7f458c7b5397aa7d2c37c5e9"><div class="ttname"><a href="classreg_1_1expression.html#a17e6c61b7f458c7b5397aa7d2c37c5e9">reg::expression::extractSymbol</a></div><div class="ttdeci">char32_t extractSymbol() const</div><div class="ttdoc">Reports this symbol expression's UTF-32-encoded symbol. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00216">expression.cpp:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab9542c8ff993613f1069590ab96fc37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9542c8ff993613f1069590ab96fc37f">&#9670;&nbsp;</a></span>getOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a7fab42d347ccf6c012c9176166723329">expression::operation</a> reg::expression::getOperation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports this RE's function. </p>
<p>Note that the <a class="el" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">empty string</a>'s function is technically that of a <a class="el" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">symbol</a>. </p><dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="classreg_1_1expression.html#a7fab42d347ccf6c012c9176166723329">expression::operation</a> best describing this RE's purpose </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00185">185</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                                   {</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  <span class="keywordflow">return</span> op;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="ac7e07c56d3c440e55cf777acc9757fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e07c56d3c440e55cf777acc9757fb8">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reg::expression::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html">expression</a> const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether this RE is semantically different from another one. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if this RE's language is exactly the same as the other one's, <code>true</code> else </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00207">207</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                                                     {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  <span class="keywordflow">return</span> !<a class="code" href="classreg_1_1expression.html#aa7efc0ec02bf455600c061b3feb6dc8f">operator==</a>(r);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_aa7efc0ec02bf455600c061b3feb6dc8f"><div class="ttname"><a href="classreg_1_1expression.html#aa7efc0ec02bf455600c061b3feb6dc8f">reg::expression::operator==</a></div><div class="ttdeci">bool operator==(expression const &amp;r) const</div><div class="ttdoc">Checks whether this RE is semantically equivalent to another one. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00193">expression.cpp:193</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7efc0ec02bf455600c061b3feb6dc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7efc0ec02bf455600c061b3feb6dc8f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reg::expression::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html">expression</a> const &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether this RE is semantically equivalent to another one. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this RE's language is exactly the same as the other one's, <code>false</code> else </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00193">193</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                                                     {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="keywordflow">if</span> (!acceptingDfa) {</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    acceptingDfa = unique_ptr&lt;dfa const&gt;(<span class="keyword">new</span> dfa(dfa::builder(gnfa(*this).splitAllTransitions()).purge().merge()));</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  }</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  <span class="keywordflow">if</span> (!r.acceptingDfa) {</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    r.acceptingDfa = unique_ptr&lt;dfa const&gt;(<span class="keyword">new</span> dfa(dfa::builder(gnfa(r).splitAllTransitions()).purge().merge()));</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  }</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  <span class="keywordflow">return</span> *acceptingDfa == *r.acceptingDfa;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="a5c0bd3dc0fafcc73b8e9ab8efb8b6daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t reg::expression::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the size of this RE's tree representation. </p>
<p>In this context, an RE's size will be defined recursively as follows:</p><ul>
<li>&empty;<code>.<a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa" title="Reports the size of this RE&#39;s tree representation. ">size()</a></code> = 0</li>
<li>&epsilon;<code>.<a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa" title="Reports the size of this RE&#39;s tree representation. ">size()</a></code> = 1</li>
<li>&lt;<code>symbol</code>&gt;<code>.<a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa" title="Reports the size of this RE&#39;s tree representation. ">size()</a></code> = 1</li>
<li><code>(l+r).<a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa" title="Reports the size of this RE&#39;s tree representation. ">size()</a></code> = 1 <code>+ l.size() + r.size()</code></li>
<li><code>(lr).<a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa" title="Reports the size of this RE&#39;s tree representation. ">size()</a></code> = 1 <code>+ l.size() + r.size()</code></li>
<li><code>(b*).<a class="el" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa" title="Reports the size of this RE&#39;s tree representation. ">size()</a></code> = 1 <code>+ b.size()</code> <dl class="section return"><dt>Returns</dt><dd>a measure of how many subexpressions this RE consists of </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00172">172</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                              {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="keywordtype">size_t</span> s(op != operation::empty);</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> <span class="keyword">const</span>&amp; re : subExpressions) {</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    s += re-&gt;size();</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="keywordflow">return</span> s;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d6474996cf285d3bc20dc9fd41eebd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6474996cf285d3bc20dc9fd41eebd9">&#9670;&nbsp;</a></span>spawnAlternation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> reg::expression::spawnAlternation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimized</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggressive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE representing the alternation of two given REs. </p>
<p>More formally, the RE's language will be <em>L</em>(<code>l</code>+<code>r</code>) = <em>L</em>(<code>l</code>) &cup; <em>L</em>(<code>r</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td><code>exptr</code> to one of the REs </td></tr>
    <tr><td class="paramname">r</td><td><code>exptr</code> to the other RE </td></tr>
    <tr><td class="paramname">optimized</td><td>whether simplifications on the syntax level should be applied </td></tr>
    <tr><td class="paramname">aggressive</td><td>whether the simplifications should check the semantic level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE representing the alternation of <code>l</code> and <code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00110">110</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                                                                                                                                {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="keywordflow">if</span> (optimized) {</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keywordflow">if</span> (l == <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>()) {</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;      <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    }</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    <span class="keywordflow">if</span> (r == <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>()) {</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="keywordflow">return</span> l;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    }</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">if</span> (l == r) {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <span class="keywordflow">return</span> l;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    <span class="keywordflow">if</span> (aggressive) {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      <span class="keywordflow">if</span> (*l == *<a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>()) {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      <span class="keywordflow">if</span> (*r == *<a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>()) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;        <span class="keywordflow">return</span> l;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      <span class="keywordflow">if</span> (*l == *r) {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">return</span> l-&gt;size() &gt; r-&gt;size() ? r : l;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;      }</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    }</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  }</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a>(<span class="keyword">new</span> expression(l, r, operation::alternation));</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a076ba2638a585eaf61bd0a2b54c263ab"><div class="ttname"><a href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">reg::expression::spawnEmptySet</a></div><div class="ttdeci">static exptr const  &amp; spawnEmptySet()</div><div class="ttdoc">Gives an RE representing the empty set ∅. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00037">expression.cpp:37</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6004691c6a9bdc5edb45640ed8b0c83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6004691c6a9bdc5edb45640ed8b0c83e">&#9670;&nbsp;</a></span>spawnConcatenation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> reg::expression::spawnConcatenation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimized</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggressive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE representing the concatenation of two given REs. </p>
<p>More formally, the RE's language will be <em>L</em>(<code>lr</code>) = <em>L</em>(<code>l</code>) &bull; <em>L</em>(<code>r</code>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td><code>exptr</code> to the first RE </td></tr>
    <tr><td class="paramname">r</td><td><code>exptr</code> to the second RE </td></tr>
    <tr><td class="paramname">optimized</td><td>whether simplifications on the syntax level should be applied </td></tr>
    <tr><td class="paramname">aggressive</td><td>whether the simplifications should check the semantic level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE representing the concatenation of <code>l</code> and <code>r</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00075">75</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                                                                                                                                  {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <span class="keywordflow">if</span> (optimized) {</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">if</span> (l == <a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>()) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;      <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    }</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="keywordflow">if</span> (r == <a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>()) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="keywordflow">return</span> l;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">if</span> (r == <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>() || l == <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>()) {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>();</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keywordflow">if</span> (aggressive) {</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      <span class="keywordflow">if</span> (*l == *<a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>()) {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keywordflow">return</span> r;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      }</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <span class="keywordflow">if</span> (*r == *<a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>()) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        <span class="keywordflow">return</span> l;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;      }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      <span class="keywordflow">if</span> (*r == *<a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>() || *l == *<a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>()) {</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>();</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      }</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    }</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a>(<span class="keyword">new</span> expression(l, r, operation::concatenation));</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_af248c8a4fac30924f5163f1bcbc378a9"><div class="ttname"><a href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">reg::expression::spawnEmptyString</a></div><div class="ttdeci">static exptr const  &amp; spawnEmptyString()</div><div class="ttdoc">Gives an RE representing the empty string ε. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00046">expression.cpp:46</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a076ba2638a585eaf61bd0a2b54c263ab"><div class="ttname"><a href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">reg::expression::spawnEmptySet</a></div><div class="ttdeci">static exptr const  &amp; spawnEmptySet()</div><div class="ttdoc">Gives an RE representing the empty set ∅. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00037">expression.cpp:37</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a076ba2638a585eaf61bd0a2b54c263ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076ba2638a585eaf61bd0a2b54c263ab">&#9670;&nbsp;</a></span>spawnEmptySet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const  &amp; reg::expression::spawnEmptySet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE representing the empty set &empty;. </p>
<p>More formally, the RE's language will be {}. </p><dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE representing the empty set &empty; </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00037">37</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;                                                 {</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;  <span class="keywordflow">return</span> expression::empty;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;}</div></div><!-- fragment -->
</div>
</div>
<a id="af248c8a4fac30924f5163f1bcbc378a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af248c8a4fac30924f5163f1bcbc378a9">&#9670;&nbsp;</a></span>spawnEmptyString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const  &amp; reg::expression::spawnEmptyString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE representing the empty string &epsilon;. </p>
<p>More formally, the RE's language will be {&epsilon;}. </p><dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE representing the empty string &epsilon; </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00046">46</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                                                    {</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">expression::spawnSymbol</a>(U<span class="charliteral">&#39;\0&#39;</span>);</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a928ef6b48e0f9edb7b10a94d115b9ef1"><div class="ttname"><a href="classreg_1_1expression.html#a928ef6b48e0f9edb7b10a94d115b9ef1">reg::expression::spawnSymbol</a></div><div class="ttdeci">static exptr const  &amp; spawnSymbol(char32_t symbol)</div><div class="ttdoc">Gives an RE representing the given UTF-32-encoded symbol. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00056">expression.cpp:56</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9c50a9f610b501317c5708ca252e590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c50a9f610b501317c5708ca252e590">&#9670;&nbsp;</a></span>spawnFromString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> reg::expression::spawnFromString </td>
          <td>(</td>
          <td class="paramtype">std::u32string const &amp;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>&#160;</td>
          <td class="paramname"><em>lits</em> = <code><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimized</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggressive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE encoded in a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">re</td><td>the RE in text form </td></tr>
    <tr><td class="paramname">lits</td><td>literals of operators in <code>re</code> </td></tr>
    <tr><td class="paramname">optimized</td><td>whether simplifications on the syntax level should be applied </td></tr>
    <tr><td class="paramname">aggressive</td><td>whether the simplifications should check the semantic level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE represented by the given string or to <code>nullptr</code> if it is invalid </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00592">592</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                                                                                                                  {</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  parser stringParser(re, lits);</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="preprocessor">  #ifdef __EXCEPTIONS</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  <span class="keywordflow">try</span> {</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    <span class="keywordflow">return</span> stringParser(optimized, aggressive);</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;  } <span class="keywordflow">catch</span> (std::bad_function_call e) {</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keywordflow">throw</span> std::invalid_argument(<span class="stringliteral">&quot;Invalid regular expression.&quot;</span>);</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;  }</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="preprocessor">  #else</span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;  <span class="keywordflow">if</span> (stringParser.badRegularExpression) {</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>();</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  }</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <span class="keywordflow">return</span> stringParser(optimized, aggressive);</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="preprocessor">  #endif</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a781d283fd52850c39b6a8f8542fcc7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781d283fd52850c39b6a8f8542fcc7c1">&#9670;&nbsp;</a></span>spawnFromString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> reg::expression::spawnFromString </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>utf8Re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>&#160;</td>
          <td class="paramname"><em>lits</em> = <code><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimized</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggressive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above for a UTF-8-encoded string. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00610">610</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                                                                                                {</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#ae9c50a9f610b501317c5708ca252e590">spawnFromString</a>(<a class="code" href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">converter</a>-&gt;from_bytes(utf8Re), lits, optimized, aggressive);</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a7ca9935b7acaa0ea9180d8755b22798e"><div class="ttname"><a href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">reg::expression::converter</a></div><div class="ttdeci">static std::unique_ptr&lt; std::wstring_convert&lt; std::codecvt_utf8&lt; char32_t &gt;, char32_t &gt; &gt; const converter</div><div class="ttdoc">Converts between UTF-8-encoded and UTF-32-encoded strings. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00096">expression.h:96</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_ae9c50a9f610b501317c5708ca252e590"><div class="ttname"><a href="classreg_1_1expression.html#ae9c50a9f610b501317c5708ca252e590">reg::expression::spawnFromString</a></div><div class="ttdeci">static exptr spawnFromString(std::u32string const &amp;re, literals lits=literals(), bool optimized=false, bool aggressive=false)</div><div class="ttdoc">Gives an RE encoded in a given string. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00592">expression.cpp:592</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0652a05601359b82254a8db1b0c9bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0652a05601359b82254a8db1b0c9bd4">&#9670;&nbsp;</a></span>spawnKleene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> reg::expression::spawnKleene </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimized</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggressive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE representing the Kleene closure of a given RE. </p>
<p>More formally, the RE's language will be <em>L</em>(<code>b</code>*) = <em>L</em>(<code>b</code>)*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td><code>exptr</code> to the RE </td></tr>
    <tr><td class="paramname">optimized</td><td>whether simplifications on the syntax level should be applied </td></tr>
    <tr><td class="paramname">aggressive</td><td>whether the simplifications should check the semantic level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE representing the Kleene closure of <code>l</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00144">144</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                                                                                                 {</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="keywordflow">if</span> (optimized) {</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">if</span> (b == <a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>() || b == <a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>()) {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>();</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    }</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">if</span> (aggressive) {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      <span class="keywordflow">if</span> (*b == *<a class="code" href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">expression::spawnEmptySet</a>() || *b == *<a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>()) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">expression::spawnEmptyString</a>();</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      }</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      <span class="keywordflow">if</span> (*b == expression(b)) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;        <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      }</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    }</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a>(<span class="keyword">new</span> expression(b));</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_af248c8a4fac30924f5163f1bcbc378a9"><div class="ttname"><a href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">reg::expression::spawnEmptyString</a></div><div class="ttdeci">static exptr const  &amp; spawnEmptyString()</div><div class="ttdoc">Gives an RE representing the empty string ε. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00046">expression.cpp:46</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a076ba2638a585eaf61bd0a2b54c263ab"><div class="ttname"><a href="classreg_1_1expression.html#a076ba2638a585eaf61bd0a2b54c263ab">reg::expression::spawnEmptySet</a></div><div class="ttdeci">static exptr const  &amp; spawnEmptySet()</div><div class="ttdoc">Gives an RE representing the empty set ∅. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00037">expression.cpp:37</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a928ef6b48e0f9edb7b10a94d115b9ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928ef6b48e0f9edb7b10a94d115b9ef1">&#9670;&nbsp;</a></span>spawnSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const  &amp; reg::expression::spawnSymbol </td>
          <td>(</td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives an RE representing the given UTF-32-encoded symbol. </p>
<p>More formally, the RE's language will be {&lt;<code>symbol</code>&gt;}. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the symbol the RE should represent or <code>&quot;&quot;</code> for the <a class="el" href="classreg_1_1expression.html#af248c8a4fac30924f5163f1bcbc378a9">empty string &epsilon;</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE representing the symbol </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00056">56</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                                              {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">return</span> expression::symbols.insert(pair&lt;char32_t,exptr&gt;(symbol, <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>(<span class="keyword">new</span> expression(symbol)))).first-&gt;second;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7f8314b5a4b6cd4494bba6b74215549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f8314b5a4b6cd4494bba6b74215549">&#9670;&nbsp;</a></span>spawnSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">expression::exptr</a> const  &amp; reg::expression::spawnSymbol </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>utf8Symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as above for a UTF-8-encoded symbol. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00061">61</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                                                                {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  char32_t u32Symbol(<a class="code" href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">converter</a>-&gt;from_bytes(utf8Symbol)[0]);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;  <span class="keywordflow">return</span> expression::symbols.insert(pair&lt;char32_t,exptr&gt;(u32Symbol, <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>(<span class="keyword">new</span> expression(u32Symbol)))).first-&gt;second;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a7ca9935b7acaa0ea9180d8755b22798e"><div class="ttname"><a href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">reg::expression::converter</a></div><div class="ttdeci">static std::unique_ptr&lt; std::wstring_convert&lt; std::codecvt_utf8&lt; char32_t &gt;, char32_t &gt; &gt; const converter</div><div class="ttdoc">Converts between UTF-8-encoded and UTF-32-encoded strings. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00096">expression.h:96</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a47f4fc0ee2c5dc0ea5af32547844275f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f4fc0ee2c5dc0ea5af32547844275f">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string reg::expression::to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes this RE in UTF-32-encoded human-readable form. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00283">283</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                                   {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">converter</a>-&gt;to_bytes(<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>());</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a7ca9935b7acaa0ea9180d8755b22798e"><div class="ttname"><a href="classreg_1_1expression.html#a7ca9935b7acaa0ea9180d8755b22798e">reg::expression::converter</a></div><div class="ttdeci">static std::unique_ptr&lt; std::wstring_convert&lt; std::codecvt_utf8&lt; char32_t &gt;, char32_t &gt; &gt; const converter</div><div class="ttdoc">Converts between UTF-8-encoded and UTF-32-encoded strings. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00096">expression.h:96</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a3ac50d9ca88f12425e26b23768fc376b"><div class="ttname"><a href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">reg::expression::to_u32string</a></div><div class="ttdeci">std::u32string to_u32string() const</div><div class="ttdoc">Describes this RE in UTF-32-encoded human-readable form. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00245">expression.cpp:245</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ac50d9ca88f12425e26b23768fc376b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac50d9ca88f12425e26b23768fc376b">&#9670;&nbsp;</a></span>to_u32string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32string reg::expression::to_u32string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes this RE in UTF-32-encoded human-readable form. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00245">245</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                                         {</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  <span class="keywordflow">switch</span> (op) {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    <span class="keywordflow">case</span> operation::alternation : <span class="keywordflow">return</span> subExpressions[0]-&gt;to_u32string().append(U<span class="stringliteral">&quot;+&quot;</span>).append(subExpressions[1]-&gt;<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>());</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    <span class="keywordflow">case</span> operation::concatenation : {</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      u32string concat;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      <span class="keywordflow">if</span> (subExpressions[0]-&gt;op &gt;= operation::alternation) {</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        concat.append(1, <span class="charliteral">&#39;(&#39;</span>);</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        concat.append(subExpressions[0]-&gt;<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>());</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        concat.append(1, <span class="charliteral">&#39;)&#39;</span>);</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        concat.append(subExpressions[0]-&gt;<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>());</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;      }</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;      <span class="keywordflow">if</span> (subExpressions[1]-&gt;op &gt;= operation::alternation) {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        concat.append(1, <span class="charliteral">&#39;(&#39;</span>);</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;        concat.append(subExpressions[1]-&gt;<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>());</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        concat.append(1, <span class="charliteral">&#39;)&#39;</span>);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        concat.append(subExpressions[1]-&gt;<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>());</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      }</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      <span class="keywordflow">return</span> concat;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;    }</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="keywordflow">case</span> operation::kleene : {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;      <span class="keywordflow">if</span> (subExpressions[0]-&gt;op &gt;= operation::concatenation) {</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="keywordflow">return</span> u32string(1, U<span class="charliteral">&#39;(&#39;</span>).append(subExpressions[0]-&gt;<a class="code" href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">to_u32string</a>()).append(U<span class="stringliteral">&quot;)*&quot;</span>);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="keywordflow">return</span> subExpressions[0]-&gt;to_u32string().append(1, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      }</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    }</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keywordflow">case</span> operation::symbol : {</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;      char32_t symbol = <a class="code" href="classreg_1_1expression.html#a17e6c61b7f458c7b5397aa7d2c37c5e9">extractSymbol</a>();</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;      <span class="keywordflow">return</span> symbol == U<span class="charliteral">&#39;\0&#39;</span> ? u32string(U<span class="stringliteral">&quot;ε&quot;</span>) : u32string(1, symbol);</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    }</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keywordflow">case</span> operation::empty : <span class="keywordflow">return</span> u32string(U<span class="stringliteral">&quot;∅&quot;</span>);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    default : <span class="keywordflow">return</span> u32string();</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;}</div><div class="ttc" id="classreg_1_1expression_html_a3ac50d9ca88f12425e26b23768fc376b"><div class="ttname"><a href="classreg_1_1expression.html#a3ac50d9ca88f12425e26b23768fc376b">reg::expression::to_u32string</a></div><div class="ttdeci">std::u32string to_u32string() const</div><div class="ttdoc">Describes this RE in UTF-32-encoded human-readable form. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00245">expression.cpp:245</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a17e6c61b7f458c7b5397aa7d2c37c5e9"><div class="ttname"><a href="classreg_1_1expression.html#a17e6c61b7f458c7b5397aa7d2c37c5e9">reg::expression::extractSymbol</a></div><div class="ttdeci">char32_t extractSymbol() const</div><div class="ttdoc">Reports this symbol expression's UTF-32-encoded symbol. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00216">expression.cpp:216</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7ca9935b7acaa0ea9180d8755b22798e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca9935b7acaa0ea9180d8755b22798e">&#9670;&nbsp;</a></span>converter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto const reg::expression::converter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= unique_ptr&lt;std::wstring_convert&lt;std::codecvt_utf8&lt;char32_t&gt;,char32_t&gt;&gt;(</div><div class="line">        <span class="keyword">new</span> std::wstring_convert&lt;std::codecvt_utf8&lt;char32_t&gt;,char32_t&gt;()</div><div class="line">    )</div></div><!-- fragment -->
<p>Converts between UTF-8-encoded and UTF-32-encoded strings. </p>

<p class="definition">Definition at line <a class="el" href="expression_8h_source.html#l00096">96</a> of file <a class="el" href="expression_8h_source.html">expression.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="expression_8h_source.html">expression.h</a></li>
<li><a class="el" href="expression_8cpp_source.html">expression.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
