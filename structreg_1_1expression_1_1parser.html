<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reglibcpp: reg::expression::parser Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">reglibcpp
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">(Naïve) C++ implementation of models for regular languages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>reg</b></li><li class="navelem"><a class="el" href="classreg_1_1expression.html">expression</a></li><li class="navelem"><a class="el" href="structreg_1_1expression_1_1parser.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structreg_1_1expression_1_1parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">reg::expression::parser Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parses regular expressions.  
 <a href="structreg_1_1expression_1_1parser.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser_1_1tree.html">tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the <a class="el" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a> entries as binary trees.  <a href="structreg_1_1expression_1_1parser_1_1tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa3a62f98413315cf3e663299175db786"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">token</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a71a26e70f208b490354302c4f3990203">A</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a6a4a22df2e375a8897bd32d0caab04c1">B</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a64deeb0d0d0abb144fad59f0ed47b481">C</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a62ccde4204ed5960a2ff26bf1f3c14f9">K</a>, 
<br />
&#160;&#160;<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a61863bf5548ef8faf3b73b78c67a5985">E</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a5f924df5b67f37cd8ddab3bc54df4637">F</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786ae404371e5408e57378571c87b5f918e5">Σ</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a74c6c5f44d773ad20e567d86b289c054">P</a>, 
<br />
&#160;&#160;<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a7dbe32910b123b24d8e0efb0f87b9c59">L</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a663bf30cc82197c6940bcbf1fc07669e">R</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786abdb3a78e07185b21ee1b39ca40e59766">S</a>, 
<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786aab2c56e6c3ee1508f97782a36c3542f6">END</a>
<br />
 }<tr class="memdesc:aa3a62f98413315cf3e663299175db786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokens the grammar deals with.  <a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa3a62f98413315cf3e663299175db786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003ad65c10bc81e481d42aaabe6ecb3"><td class="memItemLeft" align="right" valign="top">typedef bitset&lt; token::END &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a></td></tr>
<tr class="memdesc:a6003ad65c10bc81e481d42aaabe6ecb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tokens don't usually come alone.  <a href="#a6003ad65c10bc81e481d42aaabe6ecb3">More...</a><br /></td></tr>
<tr class="separator:a6003ad65c10bc81e481d42aaabe6ecb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8348b750bfcdbb22746d2ce8f64681b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a8348b750bfcdbb22746d2ce8f64681b2">parser</a> (u32string const &amp;re, <a class="el" href="structreg_1_1expression_1_1literals.html">literals</a> const &amp;<a class="el" href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">lits</a>)</td></tr>
<tr class="memdesc:a8348b750bfcdbb22746d2ce8f64681b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes with a string to parse and literals to parse for.  <a href="#a8348b750bfcdbb22746d2ce8f64681b2">More...</a><br /></td></tr>
<tr class="separator:a8348b750bfcdbb22746d2ce8f64681b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2db1db26fa698d3fb3fdf2f0b0a3157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#af2db1db26fa698d3fb3fdf2f0b0a3157">operator()</a> (bool optimized, bool aggressive)</td></tr>
<tr class="memdesc:af2db1db26fa698d3fb3fdf2f0b0a3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives the RE resulting from parsing.  <a href="#af2db1db26fa698d3fb3fdf2f0b0a3157">More...</a><br /></td></tr>
<tr class="separator:af2db1db26fa698d3fb3fdf2f0b0a3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a938ccab20264ec0f4995e6884b194778"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">getUClosure</a> (<a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> const &amp;m)</td></tr>
<tr class="memdesc:a938ccab20264ec0f4995e6884b194778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the reflexive-transitive closure of the inverse unit relation for a given set of symbols.  <a href="#a938ccab20264ec0f4995e6884b194778">More...</a><br /></td></tr>
<tr class="separator:a938ccab20264ec0f4995e6884b194778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf251ecde68976b6deb9f723fec2ad"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a22cf251ecde68976b6deb9f723fec2ad">canDerive</a> (<a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">token</a> symbol, <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> const &amp;left, <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> const &amp;right)</td></tr>
<tr class="memdesc:a22cf251ecde68976b6deb9f723fec2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a token could derive a pair of tokens from two other entries.  <a href="#a22cf251ecde68976b6deb9f723fec2ad">More...</a><br /></td></tr>
<tr class="separator:a22cf251ecde68976b6deb9f723fec2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2687d5f3c020120fd6e8ba495089f40d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a2687d5f3c020120fd6e8ba495089f40d">compileTableEntry</a> (size_t row, size_t diag, vector&lt; vector&lt; <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> &gt;&gt; &amp;<a class="el" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>)</td></tr>
<tr class="memdesc:a2687d5f3c020120fd6e8ba495089f40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a table entry.  <a href="#a2687d5f3c020120fd6e8ba495089f40d">More...</a><br /></td></tr>
<tr class="separator:a2687d5f3c020120fd6e8ba495089f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae8074a87280f292b8f6027e33d17dbdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">lits</a></td></tr>
<tr class="memdesc:ae8074a87280f292b8f6027e33d17dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores interpretations for characters encountered in the parsed string.  <a href="#ae8074a87280f292b8f6027e33d17dbdc">More...</a><br /></td></tr>
<tr class="separator:ae8074a87280f292b8f6027e33d17dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96acfad30410d2b534820f608c0cdeed"><td class="memItemLeft" align="right" valign="top">vector&lt; char32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a96acfad30410d2b534820f608c0cdeed">symbolMapping</a></td></tr>
<tr class="memdesc:a96acfad30410d2b534820f608c0cdeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the actual symbols encountered in the RE while parsing.  <a href="#a96acfad30410d2b534820f608c0cdeed">More...</a><br /></td></tr>
<tr class="separator:a96acfad30410d2b534820f608c0cdeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4945c79aaff29c997f4474baa21931"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#aea4945c79aaff29c997f4474baa21931">symbolMappingIndex</a></td></tr>
<tr class="memdesc:aea4945c79aaff29c997f4474baa21931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index for when symbols have to be extracted from the mapping.  <a href="#aea4945c79aaff29c997f4474baa21931">More...</a><br /></td></tr>
<tr class="separator:aea4945c79aaff29c997f4474baa21931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35869cfc7f69fe268e5a0e3a5622d011"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a></td></tr>
<tr class="memdesc:a35869cfc7f69fe268e5a0e3a5622d011"><td class="mdescLeft">&#160;</td><td class="mdescRight">The table of sets of symbols that derive a subsentence.  <a href="#a35869cfc7f69fe268e5a0e3a5622d011">More...</a><br /></td></tr>
<tr class="separator:a35869cfc7f69fe268e5a0e3a5622d011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72cb3d0bde672fe1649f41a61340d83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#ac72cb3d0bde672fe1649f41a61340d83">badRegularExpression</a> = false</td></tr>
<tr class="memdesc:ac72cb3d0bde672fe1649f41a61340d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the RE used to <a class="el" href="structreg_1_1expression_1_1parser.html#a8348b750bfcdbb22746d2ce8f64681b2">initialize</a> this object was invalid.  <a href="#ac72cb3d0bde672fe1649f41a61340d83">More...</a><br /></td></tr>
<tr class="separator:ac72cb3d0bde672fe1649f41a61340d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:abdef75239b69941d954715352658b9b8"><td class="memItemLeft" align="right" valign="top">static array&lt; <a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">token</a>, token::END &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#abdef75239b69941d954715352658b9b8">inverseUnitGraph</a></td></tr>
<tr class="memdesc:abdef75239b69941d954715352658b9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps symbols that may be derived in-place to their predecessing symbols.  <a href="#abdef75239b69941d954715352658b9b8">More...</a><br /></td></tr>
<tr class="separator:abdef75239b69941d954715352658b9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420803514a8ac823eb04281165dd20d3"><td class="memItemLeft" align="right" valign="top">static array&lt; array&lt; <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a>, token::END &gt;, token::END &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg_1_1expression_1_1parser.html#a420803514a8ac823eb04281165dd20d3">inverseBinaryRules</a></td></tr>
<tr class="memdesc:a420803514a8ac823eb04281165dd20d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps pairs of symbols to the symbols that derive them.  <a href="#a420803514a8ac823eb04281165dd20d3">More...</a><br /></td></tr>
<tr class="separator:a420803514a8ac823eb04281165dd20d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parses regular expressions. </p>
<p>Recognizes REs generated by the following context-free grammar, where <code>P</code> stands for the <em>alternative</em> symbol (literal &quot;<code>+</code>&quot; or &quot;<code>|</code>&quot;), <code>L</code> for a left parenthesis (literal &quot;<code>(</code>&quot;), <code>R</code> for a right parenthesis (literal &quot;<code>)</code>&quot;) and <code>S</code> for the <em>Kleene star</em> (literal &quot;<code>*</code>&quot;). <code>Σ</code> is a placeholder for any symbol that makes up the regular language described by the RE: </p><pre class="fragment">GRE=(
       {A, B, C, K, E, F},
       {Σ, P, L, R, S}, A,
       {
         (A,C), (A,AB),
         (B,PC),
         (C,K), (C,CK),
         (K,E), (K,ES),
         (E,Σ), (E,LF),
         (F,AR)
       }
    )
</pre><p>This parser is based on the article <em>To CNF or not to CNF? An Efficient Yet Presentable Version of the CYK Algorithm</em> by Martin Lange and Hans Lei&szlig;, published in <a href="https://www.informaticadidactica.de/index.php?page=issue-no-8---2008---2010"><em>informatica didactica No. 8</em></a>. Conventions will be based on this article. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00323">323</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a6003ad65c10bc81e481d42aaabe6ecb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6003ad65c10bc81e481d42aaabe6ecb3">&#9670;&nbsp;</a></span>tokens</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bitset&lt;token::END&gt; <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">reg::expression::parser::tokens</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokens don't usually come alone. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00341">341</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa3a62f98413315cf3e663299175db786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a62f98413315cf3e663299175db786">&#9670;&nbsp;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">reg::expression::parser::token</a> : unsigned char</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tokens the grammar deals with. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a71a26e70f208b490354302c4f3990203"></a>A&#160;</td><td class="fielddoc"><p>Beginning of an alternation expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a6a4a22df2e375a8897bd32d0caab04c1"></a>B&#160;</td><td class="fielddoc"><p>Second part of an alternation expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a64deeb0d0d0abb144fad59f0ed47b481"></a>C&#160;</td><td class="fielddoc"><p>A concatenation expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a62ccde4204ed5960a2ff26bf1f3c14f9"></a>K&#160;</td><td class="fielddoc"><p>Kleene expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a61863bf5548ef8faf3b73b78c67a5985"></a>E&#160;</td><td class="fielddoc"><p>Beginning of a new subexpression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a5f924df5b67f37cd8ddab3bc54df4637"></a>F&#160;</td><td class="fielddoc"><p>Second part of a new subexpression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786ae404371e5408e57378571c87b5f918e5"></a>Σ&#160;</td><td class="fielddoc"><p>A symbol expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a74c6c5f44d773ad20e567d86b289c054"></a>P&#160;</td><td class="fielddoc"><p>An alternation symbol. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a7dbe32910b123b24d8e0efb0f87b9c59"></a>L&#160;</td><td class="fielddoc"><p>A left parenthesis. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786a663bf30cc82197c6940bcbf1fc07669e"></a>R&#160;</td><td class="fielddoc"><p>A right parenthesis. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786abdb3a78e07185b21ee1b39ca40e59766"></a>S&#160;</td><td class="fielddoc"><p>A Kleene star symbol. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa3a62f98413315cf3e663299175db786aab2c56e6c3ee1508f97782a36c3542f6"></a>END&#160;</td><td class="fielddoc"><p>Number of elements in this enumeration, <b>NOT AN ACTUAL TOKEN!</b> </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00325">325</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;             : <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> {</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a71a26e70f208b490354302c4f3990203">A</a>, </div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a6a4a22df2e375a8897bd32d0caab04c1">B</a>, </div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a64deeb0d0d0abb144fad59f0ed47b481">C</a>, </div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a62ccde4204ed5960a2ff26bf1f3c14f9">K</a>, </div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a61863bf5548ef8faf3b73b78c67a5985">E</a>, </div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a5f924df5b67f37cd8ddab3bc54df4637">F</a>, </div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786ae404371e5408e57378571c87b5f918e5">Σ</a>, </div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a74c6c5f44d773ad20e567d86b289c054">P</a>, </div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a7dbe32910b123b24d8e0efb0f87b9c59">L</a>, </div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a663bf30cc82197c6940bcbf1fc07669e">R</a>, </div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786abdb3a78e07185b21ee1b39ca40e59766">S</a>, </div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786aab2c56e6c3ee1508f97782a36c3542f6">END</a> </div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    };</div><div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786aab2c56e6c3ee1508f97782a36c3542f6"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786aab2c56e6c3ee1508f97782a36c3542f6">reg::expression::parser::END</a></div><div class="ttdoc">Number of elements in this enumeration, NOT AN ACTUAL TOKEN! </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00337">expression.cpp:337</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a74c6c5f44d773ad20e567d86b289c054"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a74c6c5f44d773ad20e567d86b289c054">reg::expression::parser::P</a></div><div class="ttdoc">An alternation symbol. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00333">expression.cpp:333</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a64deeb0d0d0abb144fad59f0ed47b481"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a64deeb0d0d0abb144fad59f0ed47b481">reg::expression::parser::C</a></div><div class="ttdoc">A concatenation expression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00328">expression.cpp:328</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a7dbe32910b123b24d8e0efb0f87b9c59"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a7dbe32910b123b24d8e0efb0f87b9c59">reg::expression::parser::L</a></div><div class="ttdoc">A left parenthesis. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00334">expression.cpp:334</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a61863bf5548ef8faf3b73b78c67a5985"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a61863bf5548ef8faf3b73b78c67a5985">reg::expression::parser::E</a></div><div class="ttdoc">Beginning of a new subexpression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00330">expression.cpp:330</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786ae404371e5408e57378571c87b5f918e5"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786ae404371e5408e57378571c87b5f918e5">reg::expression::parser::Σ</a></div><div class="ttdoc">A symbol expression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00332">expression.cpp:332</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786abdb3a78e07185b21ee1b39ca40e59766"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786abdb3a78e07185b21ee1b39ca40e59766">reg::expression::parser::S</a></div><div class="ttdoc">A Kleene star symbol. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00336">expression.cpp:336</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a6a4a22df2e375a8897bd32d0caab04c1"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a6a4a22df2e375a8897bd32d0caab04c1">reg::expression::parser::B</a></div><div class="ttdoc">Second part of an alternation expression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00327">expression.cpp:327</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a663bf30cc82197c6940bcbf1fc07669e"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a663bf30cc82197c6940bcbf1fc07669e">reg::expression::parser::R</a></div><div class="ttdoc">A right parenthesis. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00335">expression.cpp:335</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a71a26e70f208b490354302c4f3990203"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a71a26e70f208b490354302c4f3990203">reg::expression::parser::A</a></div><div class="ttdoc">Beginning of an alternation expression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00326">expression.cpp:326</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a62ccde4204ed5960a2ff26bf1f3c14f9"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a62ccde4204ed5960a2ff26bf1f3c14f9">reg::expression::parser::K</a></div><div class="ttdoc">Kleene expression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00329">expression.cpp:329</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786a5f924df5b67f37cd8ddab3bc54df4637"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786a5f924df5b67f37cd8ddab3bc54df4637">reg::expression::parser::F</a></div><div class="ttdoc">Second part of a new subexpression. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00331">expression.cpp:331</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8348b750bfcdbb22746d2ce8f64681b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8348b750bfcdbb22746d2ce8f64681b2">&#9670;&nbsp;</a></span>parser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reg::expression::parser::parser </td>
          <td>(</td>
          <td class="paramtype">u32string const &amp;&#160;</td>
          <td class="paramname"><em>re</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a> const &amp;&#160;</td>
          <td class="paramname"><em>lits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes with a string to parse and literals to parse for. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00434">434</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                                                    {</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    <span class="keywordflow">if</span> (re.empty()) {</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#ac72cb3d0bde672fe1649f41a61340d83">badRegularExpression</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    }</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#aea4945c79aaff29c997f4474baa21931">symbolMappingIndex</a> = 0;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="keywordtype">size_t</span> numberOfTokens(re.length());</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#a96acfad30410d2b534820f608c0cdeed">symbolMapping</a>.reserve(numberOfTokens);</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>.reserve(numberOfTokens);</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="keywordtype">size_t</span> row(0);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="keywordflow">for</span> (char32_t symbol : re) {</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>.push_back(vector&lt;tokens&gt;(numberOfTokens-row, <a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a>()));</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      <span class="keywordflow">if</span> (symbol == <a class="code" href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">lits</a>.<a class="code" href="structreg_1_1expression_1_1literals.html#af49cf81416e49bbde051c8b512d7969f">L</a>) { <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[row][0].set(token::L); }</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symbol == <a class="code" href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">lits</a>.<a class="code" href="structreg_1_1expression_1_1literals.html#a6bf4a8973937108764b2318f364f3c4d">R</a>) { <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[row][0].set(token::R); }</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symbol == <a class="code" href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">lits</a>.<a class="code" href="structreg_1_1expression_1_1literals.html#a23b8e9441f69b4faaf2db55f33495594">P</a>) { <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[row][0].set(token::P); }</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symbol == <a class="code" href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">lits</a>.<a class="code" href="structreg_1_1expression_1_1literals.html#ae668a0daca684f2e4458f3a40b440dfd">S</a>) { <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[row][0].set(token::S); }</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <span class="keywordflow">else</span> {</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[row][0].set(token::Σ);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        <a class="code" href="structreg_1_1expression_1_1parser.html#a96acfad30410d2b534820f608c0cdeed">symbolMapping</a>.push_back(symbol);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      }</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      row++;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    }</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#a96acfad30410d2b534820f608c0cdeed">symbolMapping</a>.shrink_to_fit();</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> diag(1); diag &lt; numberOfTokens; diag++) {</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> row(0); row &lt; numberOfTokens - diag; row++) {</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;        <a class="code" href="structreg_1_1expression_1_1parser.html#a2687d5f3c020120fd6e8ba495089f40d">compileTableEntry</a>(row, diag, <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      }</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;    }</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">getUClosure</a>(<a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[0][<a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>[0].<a class="code" href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa">size</a>()-1])[token::A]) {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#ac72cb3d0bde672fe1649f41a61340d83">badRegularExpression</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    }</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  }</div><div class="ttc" id="structreg_1_1expression_1_1literals_html_ae668a0daca684f2e4458f3a40b440dfd"><div class="ttname"><a href="structreg_1_1expression_1_1literals.html#ae668a0daca684f2e4458f3a40b440dfd">reg::expression::literals::S</a></div><div class="ttdeci">char32_t const S</div><div class="ttdoc">The Kleene star. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00053">expression.h:53</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a938ccab20264ec0f4995e6884b194778"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">reg::expression::parser::getUClosure</a></div><div class="ttdeci">static tokens getUClosure(tokens const &amp;m)</div><div class="ttdoc">Constructs the reflexive-transitive closure of the inverse unit relation for a given set of symbols...</div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00358">expression.cpp:358</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a35869cfc7f69fe268e5a0e3a5622d011"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">reg::expression::parser::table</a></div><div class="ttdeci">vector&lt; vector&lt; tokens &gt; &gt; table</div><div class="ttdoc">The table of sets of symbols that derive a subsentence. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00430">expression.cpp:430</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_ac72cb3d0bde672fe1649f41a61340d83"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#ac72cb3d0bde672fe1649f41a61340d83">reg::expression::parser::badRegularExpression</a></div><div class="ttdeci">bool badRegularExpression</div><div class="ttdoc">Signifies that the RE used to initialize this object was invalid. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00431">expression.cpp:431</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_ae8074a87280f292b8f6027e33d17dbdc"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#ae8074a87280f292b8f6027e33d17dbdc">reg::expression::parser::lits</a></div><div class="ttdeci">literals lits</div><div class="ttdoc">Stores interpretations for characters encountered in the parsed string. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00427">expression.cpp:427</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a96acfad30410d2b534820f608c0cdeed"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a96acfad30410d2b534820f608c0cdeed">reg::expression::parser::symbolMapping</a></div><div class="ttdeci">vector&lt; char32_t &gt; symbolMapping</div><div class="ttdoc">Stores the actual symbols encountered in the RE while parsing. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00428">expression.cpp:428</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_aea4945c79aaff29c997f4474baa21931"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aea4945c79aaff29c997f4474baa21931">reg::expression::parser::symbolMappingIndex</a></div><div class="ttdeci">size_t symbolMappingIndex</div><div class="ttdoc">Index for when symbols have to be extracted from the mapping. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00429">expression.cpp:429</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1literals_html_af49cf81416e49bbde051c8b512d7969f"><div class="ttname"><a href="structreg_1_1expression_1_1literals.html#af49cf81416e49bbde051c8b512d7969f">reg::expression::literals::L</a></div><div class="ttdeci">char32_t const L</div><div class="ttdoc">The left parenthesis. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00053">expression.h:53</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1literals_html_a23b8e9441f69b4faaf2db55f33495594"><div class="ttname"><a href="structreg_1_1expression_1_1literals.html#a23b8e9441f69b4faaf2db55f33495594">reg::expression::literals::P</a></div><div class="ttdeci">char32_t const P</div><div class="ttdoc">The alternation symbol. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00053">expression.h:53</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a5c0bd3dc0fafcc73b8e9ab8efb8b6daa"><div class="ttname"><a href="classreg_1_1expression.html#a5c0bd3dc0fafcc73b8e9ab8efb8b6daa">reg::expression::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">Reports the size of this RE's tree representation. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00172">expression.cpp:172</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a2687d5f3c020120fd6e8ba495089f40d"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a2687d5f3c020120fd6e8ba495089f40d">reg::expression::parser::compileTableEntry</a></div><div class="ttdeci">static void compileTableEntry(size_t row, size_t diag, vector&lt; vector&lt; tokens &gt;&gt; &amp;table)</div><div class="ttdoc">Fills a table entry. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00411">expression.cpp:411</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a6003ad65c10bc81e481d42aaabe6ecb3"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">reg::expression::parser::tokens</a></div><div class="ttdeci">bitset&lt; token::END &gt; tokens</div><div class="ttdoc">Tokens don't usually come alone. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00341">expression.cpp:341</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1literals_html_a6bf4a8973937108764b2318f364f3c4d"><div class="ttname"><a href="structreg_1_1expression_1_1literals.html#a6bf4a8973937108764b2318f364f3c4d">reg::expression::literals::R</a></div><div class="ttdeci">char32_t const R</div><div class="ttdoc">The right parenthesis. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00053">expression.h:53</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a22cf251ecde68976b6deb9f723fec2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cf251ecde68976b6deb9f723fec2ad">&#9670;&nbsp;</a></span>canDerive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool reg::expression::parser::canDerive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">token</a>&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> const &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> const &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a token could derive a pair of tokens from two other entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbol</td><td>the original token </td></tr>
    <tr><td class="paramname">left</td><td>the set of tokens allowed for the first half of the result pair </td></tr>
    <tr><td class="paramname">right</td><td>the set of tokens allowed for the second half of the result pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the original token may lead to any such pair, <code>false</code> else </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00377">377</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;                                                                               {</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> leftClosure(<a class="code" href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">getUClosure</a>(left));</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> rightClosure(<a class="code" href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">getUClosure</a>(right));</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> li(0); li &lt; token::END; li++) {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">if</span> (leftClosure[li]) {</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ri(0); ri &lt; token::END; ri++) {</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      <span class="keywordflow">if</span> (rightClosure[ri]) {</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ci(0); ci &lt; token::END; ci++) {</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="structreg_1_1expression_1_1parser.html#a420803514a8ac823eb04281165dd20d3">inverseBinaryRules</a>[li][ri][ci]) {</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> successor(ci); successor != token::END; successor = <a class="code" href="structreg_1_1expression_1_1parser.html#abdef75239b69941d954715352658b9b8">inverseUnitGraph</a>[successor]) {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;            <span class="keywordflow">if</span> (symbol == successor) {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;              <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            }</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;          }</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        }</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        }</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      }</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      }</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    }</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    }</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  }</div><div class="ttc" id="structreg_1_1expression_1_1parser_html_a420803514a8ac823eb04281165dd20d3"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a420803514a8ac823eb04281165dd20d3">reg::expression::parser::inverseBinaryRules</a></div><div class="ttdeci">static array&lt; array&lt; tokens, token::END &gt;, token::END &gt; const inverseBinaryRules</div><div class="ttdoc">Maps pairs of symbols to the symbols that derive them. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00347">expression.cpp:347</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a938ccab20264ec0f4995e6884b194778"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">reg::expression::parser::getUClosure</a></div><div class="ttdeci">static tokens getUClosure(tokens const &amp;m)</div><div class="ttdoc">Constructs the reflexive-transitive closure of the inverse unit relation for a given set of symbols...</div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00358">expression.cpp:358</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a6003ad65c10bc81e481d42aaabe6ecb3"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">reg::expression::parser::tokens</a></div><div class="ttdeci">bitset&lt; token::END &gt; tokens</div><div class="ttdoc">Tokens don't usually come alone. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00341">expression.cpp:341</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_abdef75239b69941d954715352658b9b8"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#abdef75239b69941d954715352658b9b8">reg::expression::parser::inverseUnitGraph</a></div><div class="ttdeci">static array&lt; token, token::END &gt; const inverseUnitGraph</div><div class="ttdoc">Maps symbols that may be derived in-place to their predecessing symbols. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00343">expression.cpp:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2687d5f3c020120fd6e8ba495089f40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2687d5f3c020120fd6e8ba495089f40d">&#9670;&nbsp;</a></span>compileTableEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reg::expression::parser::compileTableEntry </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a table entry. </p>
<p>The entry will be filled with the set of symbols deriving the subsentence beginning at the diagonal entry in the same row and ending at the diagonal entry in the same column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the entry to fill </td></tr>
    <tr><td class="paramname">diag</td><td>the diagonal of the entry to fill </td></tr>
    <tr><td class="paramname">table</td><td>the table to operate on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of symbols deriving the subsentence </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00411">411</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                                                                                        {</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i(0); i &lt; diag; i++) {</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> first(<a class="code" href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">getUClosure</a>(table[row][i]));</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fi(0); fi &lt; first.size(); fi++) {</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="keywordflow">if</span> (first[fi]) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> second(<a class="code" href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">getUClosure</a>(table[row+1+i][diag-i-1]));</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> si(0); si &lt; second.size(); si++) {</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        <span class="keywordflow">if</span> (second[si]) {</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;          table[row][diag] |= <a class="code" href="structreg_1_1expression_1_1parser.html#a420803514a8ac823eb04281165dd20d3">inverseBinaryRules</a>[fi][si];</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        }</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        } <span class="comment">// Going through the tokens in second.</span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      }</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;      } <span class="comment">// Going through the tokens in first.</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;  }</div><div class="ttc" id="structreg_1_1expression_1_1parser_html_a420803514a8ac823eb04281165dd20d3"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a420803514a8ac823eb04281165dd20d3">reg::expression::parser::inverseBinaryRules</a></div><div class="ttdeci">static array&lt; array&lt; tokens, token::END &gt;, token::END &gt; const inverseBinaryRules</div><div class="ttdoc">Maps pairs of symbols to the symbols that derive them. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00347">expression.cpp:347</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a938ccab20264ec0f4995e6884b194778"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a938ccab20264ec0f4995e6884b194778">reg::expression::parser::getUClosure</a></div><div class="ttdeci">static tokens getUClosure(tokens const &amp;m)</div><div class="ttdoc">Constructs the reflexive-transitive closure of the inverse unit relation for a given set of symbols...</div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00358">expression.cpp:358</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a6003ad65c10bc81e481d42aaabe6ecb3"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">reg::expression::parser::tokens</a></div><div class="ttdeci">bitset&lt; token::END &gt; tokens</div><div class="ttdoc">Tokens don't usually come alone. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00341">expression.cpp:341</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a938ccab20264ec0f4995e6884b194778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938ccab20264ec0f4995e6884b194778">&#9670;&nbsp;</a></span>getUClosure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> reg::expression::parser::getUClosure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> const &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the reflexive-transitive closure of the inverse unit relation for a given set of symbols. </p>
<p>See <b>Lemma 5</b> in the article.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the set of symbols that may be derived in-place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of symbols that may be predecessors to any of the symbols in m </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00358">358</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                                             {</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a> closure;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c(0); c &lt; token::END; c++) {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">if</span> (m[c]) {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">token</a> s(static_cast&lt;token&gt;(c)); s != token::END; s = <a class="code" href="structreg_1_1expression_1_1parser.html#abdef75239b69941d954715352658b9b8">inverseUnitGraph</a>[s]) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        closure.set(s);</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      }</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    } <span class="comment">// Going through the tokens in m.</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    <span class="keywordflow">return</span> closure;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  }</div><div class="ttc" id="structreg_1_1expression_1_1parser_html_aa3a62f98413315cf3e663299175db786"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#aa3a62f98413315cf3e663299175db786">reg::expression::parser::token</a></div><div class="ttdeci">token</div><div class="ttdoc">Tokens the grammar deals with. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00325">expression.cpp:325</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_a6003ad65c10bc81e481d42aaabe6ecb3"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">reg::expression::parser::tokens</a></div><div class="ttdeci">bitset&lt; token::END &gt; tokens</div><div class="ttdoc">Tokens don't usually come alone. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00341">expression.cpp:341</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_abdef75239b69941d954715352658b9b8"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#abdef75239b69941d954715352658b9b8">reg::expression::parser::inverseUnitGraph</a></div><div class="ttdeci">static array&lt; token, token::END &gt; const inverseUnitGraph</div><div class="ttdoc">Maps symbols that may be derived in-place to their predecessing symbols. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00343">expression.cpp:343</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af2db1db26fa698d3fb3fdf2f0b0a3157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2db1db26fa698d3fb3fdf2f0b0a3157">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a> reg::expression::parser::operator() </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aggressive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives the RE resulting from parsing. </p>
<dl class="section return"><dt>Returns</dt><dd><code>exptr</code> to the RE represented by the initialization string </dd></dl>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00545">545</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                                                    {</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="structreg_1_1expression_1_1parser.html#ac72cb3d0bde672fe1649f41a61340d83">badRegularExpression</a>) {</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="preprocessor">      #ifdef __EXCEPTIONS</span></div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;      <span class="keywordflow">throw</span> std::bad_function_call();</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="preprocessor">      #else</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">exptr</a>();</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="preprocessor">      #endif</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    }</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;    <span class="keywordflow">return</span> tree(0, <a class="code" href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">table</a>.size()-1, <span class="keyword">this</span>)(optimized, aggressive);</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;  }</div><div class="ttc" id="structreg_1_1expression_1_1parser_html_a35869cfc7f69fe268e5a0e3a5622d011"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#a35869cfc7f69fe268e5a0e3a5622d011">reg::expression::parser::table</a></div><div class="ttdeci">vector&lt; vector&lt; tokens &gt; &gt; table</div><div class="ttdoc">The table of sets of symbols that derive a subsentence. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00430">expression.cpp:430</a></div></div>
<div class="ttc" id="structreg_1_1expression_1_1parser_html_ac72cb3d0bde672fe1649f41a61340d83"><div class="ttname"><a href="structreg_1_1expression_1_1parser.html#ac72cb3d0bde672fe1649f41a61340d83">reg::expression::parser::badRegularExpression</a></div><div class="ttdeci">bool badRegularExpression</div><div class="ttdoc">Signifies that the RE used to initialize this object was invalid. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8cpp_source.html#l00431">expression.cpp:431</a></div></div>
<div class="ttc" id="classreg_1_1expression_html_a74b770265b81b3c88566a66ffbc8034c"><div class="ttname"><a href="classreg_1_1expression.html#a74b770265b81b3c88566a66ffbc8034c">reg::expression::exptr</a></div><div class="ttdeci">std::shared_ptr&lt; expression const  &gt; exptr</div><div class="ttdoc">This is the type used to handle regular expressions. </div><div class="ttdef"><b>Definition:</b> <a href="expression_8h_source.html#l00043">expression.h:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac72cb3d0bde672fe1649f41a61340d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72cb3d0bde672fe1649f41a61340d83">&#9670;&nbsp;</a></span>badRegularExpression</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool reg::expression::parser::badRegularExpression = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signifies that the RE used to <a class="el" href="structreg_1_1expression_1_1parser.html#a8348b750bfcdbb22746d2ce8f64681b2">initialize</a> this object was invalid. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00431">431</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<a id="a420803514a8ac823eb04281165dd20d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420803514a8ac823eb04281165dd20d3">&#9670;&nbsp;</a></span>inverseBinaryRules</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto const reg::expression::parser::inverseBinaryRules</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    []()-&gt;array&lt;array&lt;expression::parser::tokens,expression::parser::token::END&gt;,expression::parser::token::END&gt;{</div><div class="line">  array&lt;tokens,token::END&gt; noPredecessor;</div><div class="line">  noPredecessor.fill(<a class="code" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a>());</div><div class="line">  array&lt;array&lt;tokens,token::END&gt;,token::END&gt; rules;</div><div class="line">  rules.fill(noPredecessor);</div><div class="line">  rules[token::A][token::B].set(token::A);</div><div class="line">  rules[token::P][token::C].set(token::B);</div><div class="line">  rules[token::C][token::K].set(token::C);</div><div class="line">  rules[token::E][token::S].set(token::K);</div><div class="line">  rules[token::L][token::F].set(token::E);</div><div class="line">  rules[token::A][token::R].set(token::F);</div><div class="line">  <span class="keywordflow">return</span> rules;</div><div class="line">}()</div></div><!-- fragment -->
<p>Maps pairs of symbols to the symbols that derive them. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00347">347</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<a id="abdef75239b69941d954715352658b9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdef75239b69941d954715352658b9b8">&#9670;&nbsp;</a></span>inverseUnitGraph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto const reg::expression::parser::inverseUnitGraph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    []()-&gt;array&lt;expression::parser::token,expression::parser::token::END&gt;{</div><div class="line">  array&lt;token,token::END&gt; graph;</div><div class="line">  graph.fill(token::END);</div><div class="line">  graph[token::Σ] = token::E;</div><div class="line">  graph[token::E] = token::K;</div><div class="line">  graph[token::K] = token::C;</div><div class="line">  graph[token::C] = token::A;</div><div class="line">  <span class="keywordflow">return</span> graph;</div><div class="line">}()</div></div><!-- fragment -->
<p>Maps symbols that may be derived in-place to their predecessing symbols. </p>
<p>See <b>Definition 2</b> and <b>Lemma 4</b> in the article. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00343">343</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<a id="ae8074a87280f292b8f6027e33d17dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8074a87280f292b8f6027e33d17dbdc">&#9670;&nbsp;</a></span>lits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreg_1_1expression_1_1literals.html">literals</a> reg::expression::parser::lits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores interpretations for characters encountered in the parsed string. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00427">427</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<a id="a96acfad30410d2b534820f608c0cdeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96acfad30410d2b534820f608c0cdeed">&#9670;&nbsp;</a></span>symbolMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;char32_t&gt; reg::expression::parser::symbolMapping</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the actual symbols encountered in the RE while parsing. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00428">428</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<a id="aea4945c79aaff29c997f4474baa21931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4945c79aaff29c997f4474baa21931">&#9670;&nbsp;</a></span>symbolMappingIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t reg::expression::parser::symbolMappingIndex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index for when symbols have to be extracted from the mapping. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00429">429</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<a id="a35869cfc7f69fe268e5a0e3a5622d011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35869cfc7f69fe268e5a0e3a5622d011">&#9670;&nbsp;</a></span>table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;<a class="el" href="structreg_1_1expression_1_1parser.html#a6003ad65c10bc81e481d42aaabe6ecb3">tokens</a>&gt; &gt; reg::expression::parser::table</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The table of sets of symbols that derive a subsentence. </p>

<p class="definition">Definition at line <a class="el" href="expression_8cpp_source.html#l00430">430</a> of file <a class="el" href="expression_8cpp_source.html">expression.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="expression_8cpp_source.html">expression.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
